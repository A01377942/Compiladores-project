/*
Zabdiel Valentin A01377950
Emiliano Javier Gómez Jiménez A01377235
Luis Jonathan Rosas Ramos A01377942
*/

using System;
using System.Text;
using System.Collections.Generic;

namespace QuetzalDragon
{

    class WatVisitor
    {

        //IDictionary<string, Type> table;
        //Variables globales
        public ISet<string> Vgst
        {
            get;
            private set;
        }
        public IDictionary<string, Entry> Fgst
        {
            get;
            private set;
        }

        public WatVisitor(IDictionary<string, Entry> Fgst, ISet<string> Vgst)
        {
            this.Fgst = Fgst;
            this.Vgst = Vgst;
        }

        public string GenerateLabel()
        {
            return string.Format("${0:00000}", labelCounter++);
        }

        private string currentFunction = "";
        private bool areVariablesSet = false;

        private bool isReturn = false;
        int labelCounter = 0;


        //ADD_Z
        public static IList<int> AsCodePoints(string str)
        {
            var result = new List<int>(str.Length);
            for (var i = 0; i < str.Length; i++)
            {
                result.Add(char.ConvertToUtf32(str, i));
                if (char.IsHighSurrogate(str, i))
                {
                    i++;
                }
            }
            return result;
        }

        public string Visit(Program node)
        {
            return ";; WebAssembly text format code generated by "
                + "the QuetzalDragon compiler.\n\n"
                + "(module\n"
                + "  (import \"quetzal\" \"printi\" (func $printi (param i32) (result i32)))\n"
                + "  (import \"quetzal\" \"printc\" (func $printc (param i32) (result i32)))\n"
                + "  (import \"quetzal\" \"prints\" (func $prints (param i32) (result i32)))\n"
                + "  (import \"quetzal\" \"println\" (func $println (result i32)))\n"
                + "  (import \"quetzal\" \"readi\" (func $readi (result i32)))\n"
                + "  (import \"quetzal\" \"reads\" (func $reads (result i32)))\n"
                + "  (import \"quetzal\" \"new\" (func $new (param i32) (result i32)))\n"
                + "  (import \"quetzal\" \"size\" (func $size (param i32) (result i32)))\n"
                + "  (import \"quetzal\" \"add\" (func $add (param i32 i32) (result i32)))\n"
                + "  (import \"quetzal\" \"get\" (func $get (param i32 i32) (result i32)))\n"
                + "  (import \"quetzal\" \"set\" (func $set (param i32 i32 i32) (result i32)))\n"
                + declareGlobalVariables()
                + Visit((dynamic)node[0])
                + "  )\n"
                + ")\n";
        }

        public string Visit(Def_list node)
        {

            return VisitChildrenInDefList(node);

        }

        public string declareGlobalVariables()
        {

            //si hay variables globales, las declaras en wat
            if (Vgst.Count > 0)
            {
                var sb = new StringBuilder();
                foreach (var entry in Vgst)
                {
                    sb.Append($"  (global ${entry} (mut i32) (i32.const 0))\n");

                }
                return sb.ToString();
            }
            return "\n";
        }


        public string VisitChildrenInDefList(Node node)
        {

            var sb = new StringBuilder();
            foreach (var n in node)
            {
                if (n.GetType().Name.Equals("Fun_Def"))
                {

                    currentFunction = n.AnchorToken.Lexeme;
                    sb.Append(Visit((dynamic)n));
                    areVariablesSet = false;
                    isReturn = false;
                }

            }
            return sb.ToString();
        }

        public string Visit(Fun_Def node)
        {
            var sb = new StringBuilder();
            var funtionName = node.AnchorToken.Lexeme;
            //si la funcion no es main, la define
            if (!funtionName.Equals("main"))
            {
                sb.Append($"  (func ${funtionName}\n");

                //Agrega parametros
                var parametrosArray = Fgst[funtionName].arrayLst();
                for (int i = 0; i < Fgst[funtionName].Arity; i++)
                {
                    sb.Append($"  (param ${parametrosArray[i]} i32)\n");
                }
                sb.Append($"  (result i32)\n");
                sb.Append($"   (local $_temp i32)\n");

                //Agregar cuerpo funcion
                foreach (var n in node)
                {

                    sb.Append(Visit((dynamic)n));

                }
                if (isReturn == false)
                {
                    sb.Append("   i32.const 0\n");
                    sb.Append("   return\n");
                }

                sb.Append("  )\n");
            }
            //si es  main
            else
            {
                sb.Append("  (func\n");
                sb.Append("    (export \"main\")\n");
                sb.Append("    (result i32)\n");
                sb.Append($"   (local $_temp i32)\n");
                //Agregar cuerpo funcion
                foreach (var n in node)
                {

                    sb.Append(Visit((dynamic)n));

                }
                if (isReturn == false)
                {
                    sb.Append("  i32.const 0\n");
                }

            }




            return sb.ToString();

        }

        public string Visit(Stmt_List node)
        {

            return VisitChildren(node);
        }

        public string Visit(Stmt_If node)
        {
            var sb = new StringBuilder();
            //Se evalua el boleano
            sb.Append(Visit((dynamic)node[0]));
            sb.Append("   if\n");
            sb.Append(VisitChildren(node));
            sb.Append("   end\n");
            return sb.ToString();
        }

        public string Visit(Array node)
        {
            var sb = new StringBuilder();
            //Evaluar los argumentos
            var nodoExpr_List = (Expr_List)(dynamic)node[0];

            sb.Append("  ;; Arreglo\n");
            sb.Append("    i32.const 0\n");
            sb.Append("    call $new\n");
            sb.Append("    local.set $_temp\n");

            for (int i = 0; i < nodoExpr_List.NumberChildrens + 1; i++)
            {
                sb.Append("   local.get $_temp\n");
            }

            foreach (var n in nodoExpr_List)
            {
                sb.Append(Visit((dynamic)n));
                sb.Append("   call $add\n");
                sb.Append("   drop\n");
            }

            return sb.ToString();
        }

        string breakLabel = null;


        public string Visit(Stmt_Loop node)
        {
            var et1 = GenerateLabel();
            var et2 = GenerateLabel();
            var oldLabel = breakLabel;
            breakLabel = et1;
            var result =
               ";;loop \n" +
               "    block  " + et1 + "\n"
               + "      loop  " + et2 + "\n"
               + Visit((dynamic)node[0])
               + "    br  " + et2 + "\n"
               + "      end\n"
               + "    end\n";
            breakLabel = oldLabel;
            return result;

        }

        public string Visit(Stmt_Break node)
        {
            return "    br  " + breakLabel + "\n";
        }


        public string Visit(Else_If_List node)
        {
            var sb = new StringBuilder();

            return sb.ToString();
        }



        public string Visit(Else node)
        {
            var sb = new StringBuilder();

            return sb.ToString();
        }

        public string Visit(Assign node)
        {
            var nombreVariable = obtenerNombreIdentifier((dynamic)node[0]);
            var result = "";
            //Analizar si mi variable es local o global
            //Si es local
            if (Fgst[currentFunction].Lst.Contains(nombreVariable))
            {
                result = $"    local.set ${nombreVariable}\n";
            }
            //Si es global
            else
            {
                result = $"    global.set ${nombreVariable}\n";
            }

            return Visit((dynamic)node[1])
                    + result;
        }

        public string obtenerNombreIdentifier(Identifier node)
        {
            return $"{node.AnchorToken.Lexeme}";
        }

        //
        public string Visit(Identifier node)
        {
            //Checar si es variable global
            if (Vgst.Contains(node.AnchorToken.Lexeme))
            {
                return $"    global.get ${node.AnchorToken.Lexeme}\n";
            }

            return $"    local.get ${node.AnchorToken.Lexeme}\n";
        }

        public string Visit(IntLiteral node)
        {
            return $"    i32.const {node.AnchorToken.Lexeme}\n";
        }


        public string Visit(FUN_CALL node)
        {
            var sb = new StringBuilder();

            //Funcion
            var nodoIdentificador = node[0];
            var nombreFuncion = nodoIdentificador.AnchorToken.Lexeme;

            //Agregar parametros
            sb.Append(Visit((dynamic)node[1]));

            //llamar funcion
            sb.Append($"   call ${nombreFuncion}\n");
            if (node.isStatement)
            {
                sb.Append("   drop\n");
            }


            return sb.ToString();

        }

        public string Visit(Expr_List node)
        {
            return VisitChildren(node);
        }

        public string VisitChildren(Node node)
        {
            var sb = new StringBuilder();
            foreach (var n in node)
            {
                sb.Append(Visit((dynamic)n));
            }
            return sb.ToString();
        }

        //Zab
        public string Visit(Stmt_Return node)
        {
            isReturn = true;
            var sb = new StringBuilder();
            sb.Append(Visit((dynamic)node[0]));
            sb.Append("   return\n");

            return sb.ToString();
        }

        //Zab
        public string Visit(NOT node)
        {
            var sb = new StringBuilder();
            sb.Append(Visit((dynamic)node[0]));
            sb.Append("   i32.eqz\n");
            return sb.ToString();
        }
        //Zab
        public string Visit(Empty node)
        {
            var sb = new StringBuilder();
            return sb.ToString();
        }

        //Zab
        public string Visit(String Node)
        {
            var sb = new StringBuilder();
            var stringLexeme = Node.AnchorToken.Lexeme;
            var newString = stringLexeme.Substring(1, stringLexeme.Length - 2);
            var charArray = newString.ToCharArray();
            var index = 0;
            var stringSize = 0;

            //Recorrer el String que esta en un arreglo de characters
            while (index < charArray.Length)
            {
                //Si solamente es un character normal, ex 'A', agregar su codigo
                if (charArray[index].ToString() != @"\")
                {

                    sb.Append("i32.const " + AsCodePoints(charArray[index].ToString())[0] + ";; " + charArray[index].ToString() + "\n");
                    sb.Append("call $add\n");
                    sb.Append("drop\n");
                    sb.Append("\n");
                    index++;
                    stringSize++;
                }
                //Si contiene el character "\", entonces validar si ...
                else
                {
                    //validar si se puede saber su valor completo, ex "\n", "\r".
                    if (index + 1 < charArray.Length)
                    {
                        switch (charArray[index + 1])
                        {
                            //Si en realidad es "/n", entonces agrega su codigo
                            case 'n':
                                sb.Append("i32.const 10" + ";; " + @"\n" + "\n");
                                sb.Append("call $add\n");
                                sb.Append("drop\n");
                                sb.Append("\n");
                                index += 2;
                                stringSize++;
                                break;
                            //falta agregar mas casos

                            //Si en realidad solo es el character "\" , entonces agregar su codigo
                            default:
                                sb.Append("i32.const " + AsCodePoints(charArray[index].ToString())[0] + ";; " + charArray[index].ToString() + "\n");
                                sb.Append("call $add\n");
                                sb.Append("drop\n");
                                sb.Append("\n");
                                index++;
                                stringSize++;
                                break;
                        }
                    }

                    //Si en realidad tienes un caso como "\",entonces
                    else
                    {

                        sb.Append("i32.const " + AsCodePoints(charArray[index].ToString())[0] + ";; " + charArray[index].ToString() + "\n");
                        sb.Append("call $add\n");
                        sb.Append("drop\n");
                        sb.Append("\n");
                        index++;
                        stringSize++;
                    }
                }


            }
            var sb2 = new StringBuilder();
            sb2.Append(" i32.const 0\n");
            sb2.Append(" call $new\n");
            sb2.Append(" local.set $_temp\n");
            for (int i = 0; i < stringSize + 1; i++)
            {
                sb2.Append(" local.get $_temp\n");
            }

            sb2.Append("\n");
            sb2.Append(sb.ToString());
            return sb2.ToString();
        }

        public string Visit(MULTIPLICATION node)
        {
            var sb = new StringBuilder();
            //Como la multiplicacion siempre tiene dos hijos
            //primero obtienes el valor de los hijos
            sb.Append(Visit((dynamic)node[0]));
            sb.Append(Visit((dynamic)node[1]));

            //despues multiplicas
            sb.Append("   i32.mul\n");
            return sb.ToString();
        }

        //Jonathan Implementations

        public string VisitChildren(MULTIPLICATION node)
        {
            return VisitBinaryOperator("i32.mul", node);
        }

        public string VisitChildren(Expr_And node)
        {
            return VisitBinaryOperator("i32.and", node);
        }

        public string VisitChildren(Expr_Or node)
        {
            return VisitBinaryOperator("i32.or", node);
        }

        public string VisitChildren(PLUS node)
        {
            return VisitBinaryOperator("i32.add", node);
        }

        public string VisitChildren(DIVISION node)
        {
            return VisitBinaryOperator("i32.div_s", node);
        }

        public string VisitChildren(REMINDER node)
        {
            return VisitBinaryOperator("i32.rem_s", node);
        }

        public string VisitChildren(EQUAL_TO node)
        {
            return VisitBinaryOperator("i32.eq", node);
        }

        public string VisitChildren(NOT_EQUAL_TO node)
        {
            return VisitBinaryOperator("i32.ne", node);
        }
        public string VisitChildren(LESS_THAN node)
        {
            return VisitBinaryOperator("i32.lt_s", node);
        }
        public string VisitChildren(LESS_EQUAL_THAN node)
        {
            return VisitBinaryOperator("i32.le_s", node);
        }


        //Declara variables
        //funciona tanto para argumentos de funcion como para declaracion de variables.
        public string Visit(VarDefList node)
        {
            var sb = new StringBuilder();
            // foreach (var n in node) {
            //     sb.Append(declareLocalVariable((dynamic) n));
            // }
            var arguments = Fgst[currentFunction].arrayLst();

            if (areVariablesSet != true)
            {
                for (int i = Fgst[currentFunction].Arity; i < arguments.Length; i++)
                {
                    sb.Append($"    (local ${arguments[i]} i32)\n");
                }
                areVariablesSet = true;
            }
            return sb.ToString();

        }

        public string declareLocalVariable(Identifier node)
        {

            //return $"    local.set ${node.AnchorToken.Lexeme}\n";
            return $"    (local ${node.AnchorToken.Lexeme} i32)\n";
        }

        string VisitBinaryOperator(string op, Node node)
        {
            return Visit((dynamic)node[0])
                + Visit((dynamic)node[1])
                + $"    {op}\n";
        }
    }
}
